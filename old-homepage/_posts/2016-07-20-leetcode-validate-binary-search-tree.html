---
layout: post
title: "[LeetCode] Validate Binary Search Tree"
categories: leetcode
tags:
- leetcode
- BST
- inorder
---
<p><strong>Questionï¼š</strong></p>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <b>less than</b> the node's key.</li>
<li>The right subtree of a node contains only nodes with keys <b>greater than</b> the node's key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li><br />
</ul>
<strong>Thoughts:</strong></p>
<p>1. Wrong: The first solution come to my mind is the one of Integer.MIN_VALUE and Integer.MAX_VALUE. You can Google it and you will get more details. Here is the code that I come up with at the first time. But it's not accepted due to LeetCode added more test cases. Most of the added test cases are edge cases, like Integer.MIN_VALUE and Integer.MAX_VALUE.</p>
<p>2. The right solution should be Inorder scan the tree, and add each value into a list. If the tree is a binary search tree, the list should be sorted at last. The space complexity is O(n) though.</p>

<h3>Solution:</h3>
{% highlight java %}
public class Solution {
    public boolean isValidBST(TreeNode root) {
        LinkedList<Integer> list = new LinkedList<Integer>();
        inorder(root, list);
        int size = list.size();
        for(int i=0; i<size-1; i++){ // check if the array is sorted
            if(list.get(i) >= list.get(i+1)){
                return false;
            }
        }
        return true;
    }
    public void inorder(TreeNode node, LinkedList<Integer> list){
        if(node == null) return;
        if(node.left != null) inorder(node.left, list);
        list.add(node.val);
        if(node.right != null) inorder(node.right, list);
    }
}
{% endhighlight %}
